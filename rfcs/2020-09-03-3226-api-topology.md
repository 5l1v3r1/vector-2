# RFC #3226 - 2020-09-03 - API Topology

This RFC discusses configuration, implementation and potential schema for the API to co-exist with, and observe, existing Vector topology.

## Scope

* Implementation of the API server alongside existing topology.
* Configuration in `vector.toml` to set-up / enable the API.
* GraphQL types to observe existing topology (pending #3648)

## Motivation

I implemented the first draft of a GraphQL API server in #3514, and made changes to the toplogy mod to accommodate it. @lukesteensen [commented](https://github.com/timberio/vector/pull/3514#discussion_r479517596) with a preference to keep the API out of the existing topology mod.

This raises several design questions:

* Where should the API live?
* If the API is outside of topology, what are our expectations with users making API configuration changes in `vector.toml` and handling SIGHUP/reloading? (The initial draft in #3514 )
* Which parts of the API are configurable?
* What are our expectations for enabling/disabling the config?
* Should the API be treated as a sink - or exist as a layer atop topology?

Additionally, there are questions about observing topology:

* Should the API consume `internal_metrics` as a source - or subscribe directly to the controller, to override source configuration?
* More generally - how will the API observe sources/sinks/transforms?

This RFC demonstrates various possibilities intended to solicit debate. I'll note my preferred routes where applicable, but for the most part, will defer heavily to codeowners with more experience in these code paths.

## Internal Proposal

### Disable the API by default

I think the API should be disabled by default, and require explicit enabling in `vector.toml`.

Through the API, users have access to internal metrics. This will likely grow to accommodate viewing/validating configuration (which may also include sensitive external provider keys) and specific log lines, which may contain non-anonymized, identifying end-user data.

Enabling the API by default risks accidental leakage by Vector users who may be unaware of the API feature, and may therefore fail to lock it down. Security misconfiguration accounts for [10 out of 50 top breaches](https://snyk.io/blog/owasp-top-10-breaches/).

In #3514, the API is enabled with the following configuration in `vector.toml`:

```toml
[api]
    enabled = true
```

### Runs on port 8686 (configurable)

I propose running on port 8686 by default. (86 is 'V' in ASCII; this represents the 'VV' in the Vector logo.)

This competes with the default port used by Sun App Server JMX/RMI, but doesn't feature on Wikipedia's list of [well-known ports](https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#Well-known_ports).

Since there's little overlap and usage is generally quite low, I think this is a safe default.

In #3514, users can override the port with:

```toml
[api]
    bind = "<ip>:<port>"
```

### Reloadable API config

I propose reloading the API when config changes are detected, and Vector is run with the `-w` watch flag.

Rationale:

1. I think it would be surprising to users if the API configuration didn't automatically reload when the watch flag was explicitly set.

2. It ensures consistency between sections of config that already do reload on changes.

3. Depending on how topology is configured (whether we opt to treat the API as a configurable sink), it might be necessary (or easier) to tear down the API and pick up source changes that feed into it, than continue with a running API server that may have active subscriptions observing topology that has been removed.

I could do with a consensus on:

- Whether others agree with this feature.
- If so, how this should co-exist with topology factoring the proposed changes to topology and wanting to keep this separate.

### Observing metrics

Metrics are currently observed by attaching directly to the `internal_metrics` controller, and producing a stream that an individual subscription can subscribe to (see #3648 for the definition of 'subscription' in the context of GraphQL):

```rust
/// Returns a stream of `Metric`s, collected at the provided millisecond interval
fn get_metrics(interval: i32) -> impl Stream<Item = Metric> {
    let controller = get_controller().unwrap();
    let mut interval = tokio::time::interval(Duration::from_millis(interval as u64));

    stream! {
        while let _ = interval.tick().await {
            for ev in capture_metrics(&controller) {
                if let Event::Metric(m) = ev {
                    yield m
                }
            }
        }
    }
}
```

This is outside of the `internal_metrics` -> sink flow, for the following reasons:

1. The `internal_metrics` source emits metrics on a fixed 2-second interval. Subscribing to a controller directly enables this interval to be defined by the client. Even if this winds up being something that isn't user-configurable, it provides the API with granularity that may not be applicable in a non-API context.

2. It's unaffected by user configuration. If other control flags determine how `internal_metrics` are emitted, this API needn't design for these scenarios.

3. It's a simple paradigm for producing direct streams that can be shared across subscriptions, without concern for global topology.

4. Other aspects of the API - such as observing source/sink/transform topology, reading specific event lines, or validating `vector.toml`, are possibly outside of the source -> sink paradigm, and would require observability that is unlikely to fit this pipeline.

### API is not a sink

TBD

## Doc-level Proposal

TBD

## Rationale

TBD

## Prior Art

TBD

## Drawbacks

TBD

## Alternatives

TBD

## Outstanding Questions

TBD

## Plan Of Attack

TBD
